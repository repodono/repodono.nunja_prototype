Given these data (programming languages)

  - Java
  - JavaScript
  - Python
  - PHP
  - Ruby

With an interaction that allows users to search for languages by its
starting character(s).  Two templates follow

  form.jinja

  <form>
    <label>Search: <input type="text" name="q" /></label>
    <input type="submit" value="Search" />
    <div>List of languages</div>

    {{ results }}

  </form>

(Note: the above template can be done in _any_ language, provided that
it has a specific placeholder to render the results provided by the
jinja template)

Where results is generated by this template:

  mod/language-list.jinja

  <ul {{ nunja_id }}>
  {% for item in items %}
    <li>{{ item }}</li>
  {% endfor %}
  </ul>

Gives a rendering when P is passed as a query parameter on first
render on the server side like so::

  <form>
    <label>Search: <input type="text" name="q" /></label>
    <input type="submit" value="Search" />
    <div>List of languages</div>

    <ul data-nunja="mod/language-list">
      <li>Python</li>
      <li>PHP</li>
    </ul>

  </form>

The Javascript side should be able to hook into the submit event for
the input, so that if user enters `j` into the search field and submit,
the full trip will not be made but instead the mod/language-list.jinja
template will be loaded by nunja which then passed into nunjucks and the
correct response will be generated.

The script that accompany the script will need to figure out how to poke
above outside its managed scope (i.e. the ul node) and find the button
without globally attaching its trigger event to elements outside its
intended scope.

Other things to consider:

- Definition of common endpoints (pointing to the source that generates
  the data dict in Python, the one that returns JSON over the same thing
  as an HTTP endpoint.
- Consider the relationship/usage of the pushState API to maintain URL
  consistency between the two different requests.

i18n considerations

Instead of having the template doing things like:

    <dl>
      <dt>Name</dt>
      <dd>{{ name }}</dd>
    </dl>

Templates may have to look something like

    <dl>
      <dt>{{ _('Name'} }}</dt>
      <dd>{{ name }}</dd>
    </dl>

The engine (or the user) have to somehow inject the i18n resolver `_` to
the molding/templating engine.
